#pragma once

#define CL_HPP_CL_1_2_DEFAULT_BUILD
#define CL_HPP_TARGET_OPENCL_VERSION 120
#define CL_HPP_MINIMUM_OPENCL_VERSION 120
#define CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY 1

#include <CL/cl2.hpp>

class KernelLidarProc {
   private:
    static const unsigned int rangesParamOffset = 0;
    static const unsigned int rangesSizeParamOffset = rangesParamOffset + 1;
    static const unsigned int numScansParamOffset = rangesSizeParamOffset + 1;
    static const unsigned int scanStartAngleParamOffset = numScansParamOffset + 1;
    static const unsigned int scanAngleIncParamOffset = scanStartAngleParamOffset + 1;
    static const unsigned int stepperStartAngleParamOffset = scanAngleIncParamOffset + 1;
    static const unsigned int stepperAngleIntParamOffset = stepperStartAngleParamOffset + 1;
    static const unsigned int lidarHeightOffsetParamOffset = stepperAngleIntParamOffset + 1;
    static const unsigned int outBufParamOffset = lidarHeightOffsetParamOffset + 1;

    cl::Context context;
    cl::CommandQueue queue;
    std::vector<char> binBuf;
    cl::Program::Binaries binaries;
    std::vector<cl::Device> devices;
    cl::Program program;
    cl::Kernel kernel;
    cl::Buffer rangesBuf;
    cl::Buffer outBuf;

    float *rangesPtr; //!< Holds all 2D lidar scans.
    int rangesSize = -1; //!< Size of rangesPtr.

    uint8_t *cloudPtr; //!< Holds point cloud generated by krnl_lidar_proc.
    int cloudSize = -1; //!< Size of cloudPtr.

    /**
     * @brief Find Xilinx device.
     * @return True if found.
     */
    bool findDevice();

    /**
     * @brief Load binary from xclbin file.
     * @param xclbin Path to .xclbin.
     * @return True on success.
     */
    bool loadBinary(const std::string &xclbin);

   public:
    /**
     * @brief Construct a new Kernel Lidar Proc object but dont touch FPGA yet.
     */
    KernelLidarProc() = default;

    /**
     * @brief Construct a new Kernel Lidar Proc object and load it to FPGA.
     * @param xclbin Path to .xclbin file.
     */
    KernelLidarProc(const std::string &xclbin);

    /**
     * @brief Destroy the Kernel Lidar Proc object.
     * 
     */
    ~KernelLidarProc();

    /**
     * @brief Load .xclbin to FPGA.
     * @param xclbin Path to .xclbin.
     * @return True on success.
     */
    bool init(const std::string &xclbin);

    /**
     * @brief Finish all the work with kernels.
     */
    void deinit();

    /**
     * @brief Set some arguments that are persistent for the lifetime of the kernels.
     * @param num2DScans Number of 2D scans per full scan.
     * @param single2DScanSize  Size of single 2D scan in samples.
     * @param scan2DStartAngle Start angle of 2D scan in radians.
     * @param scan2DAngleInc  Angle increment of 2D scan in radians.
     * @param centerOffset Offset from center of the cradle (threaded rod) to 2D LIDAR.
     * @return True on success.
     */
    bool setPersistentArgs(unsigned int num2DScans, unsigned int single2DScanSize, float scan2DStartAngle, float scan2DAngleInc, float centerOffset);
    
    /**
     * @brief Allocate buffers required by kernels.
     * @param rangesSize Total number of samples from all 2D scans.
     * @param cloudSize Size of cloud point in bytes.
     * @return True on success.
     */
    bool allocateBuffers(int rangesSize, int cloudSize);

    /**
     * @brief Insert one 2D scan into ranges buffer at given offset. The ranges must fit into the pre allocated buffer.
     * @param ranges Ranges to put into ranges buffer.
     * @param offset Offset from start of the buffer.
     */
    void setRangesChunk(const std::vector<float> &ranges, unsigned int offset);

    /**
     * @brief Run the kernel.
     * @param stepperStartAngle Start angle of the stepper for recent full scan (the one loaded via setRangesChunk).
     * @param stepperAngleInc Angle increment of the stepper motor for recent full scan.
     * @return True on success.
     */
    bool runCloudGen(float stepperStartAngle, float stepperAngleInc);

    /**
     * @brief Copy runCloudGen's result from OpenCL's buffer into given vector.
     * @param buf Vector to copy result to.
     */
    void getCloudBuf(std::vector<uint8_t> &buf);
};