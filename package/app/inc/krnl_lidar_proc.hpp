#pragma once

#define CL_HPP_CL_1_2_DEFAULT_BUILD
#define CL_HPP_TARGET_OPENCL_VERSION 120
#define CL_HPP_MINIMUM_OPENCL_VERSION 120
#define CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY 1

#include <CL/cl2.hpp>

class KernelLidarProc {
   private:
    struct RangesToCloudParamOffsets {
        const unsigned int rangesBuf = 0;
        const unsigned int single2DScanSize = 1;
        const unsigned int num2DScans = 2;
        const unsigned int scan2DStartAngle = 3;
        const unsigned int scan2DAngleInc = 4;
        const unsigned int stepperStartAngle = 5;
        const unsigned int stepperAngleInc = 6;
        const unsigned int centerOffset = 7;
        const unsigned int cloudBuf = 8;
    };
    RangesToCloudParamOffsets rangesToCloudParamOffsets;

    struct RangesToProjectionParamOffsets {
        const unsigned int rangesBuf = 0;
        const unsigned int single2DScanSize = 1;
        const unsigned int num2DScans = 2;
        const unsigned int scan2DStartAngle = 3;
        const unsigned int scan2DAngleInc = 4;
        const unsigned int scan2DMaxRange = 5;
        const unsigned int stepperStartAngle = 6;
        const unsigned int stepperAngleInc = 7;
        const unsigned int stepperEndstopAngle = 8;
        const unsigned int projectionBuf = 9;
        const unsigned int imgWidth = 10;
        const unsigned int imgHeight = 11;
    };
    RangesToProjectionParamOffsets rangesToProjectionParamOffsets;

    struct ProjectionToCloudParamOffsets {
        const unsigned int rangesBuf = 0;
        const unsigned int single2DScanSize = 1;
        const unsigned int num2DScans = 2;
        const unsigned int scan2DStartAngle = 3;
        const unsigned int scan2DAngleInc = 4;
        const unsigned int stepperStartAngle = 5;
        const unsigned int stepperAngleInc = 6;
        const unsigned int stepperEndstopAngle = 7;
        const unsigned int centerOffset = 8;
        const unsigned int projectionInferenceBuf = 9;
        const unsigned int imgWidth = 10;
        const unsigned int imgHeight = 11;
        const unsigned int cloudInferenceBuf = 12;
    };
    ProjectionToCloudParamOffsets projectionToCloudParamOffsets;

    cl::Context context;
    cl::CommandQueue queue;
    std::vector<char> binBuf;
    cl::Program::Binaries binaries;
    std::vector<cl::Device> devices;
    cl::Program program;
    cl::Kernel rangesToCloud;
    cl::Kernel rangesToProjection;
    cl::Kernel projectionToCloud;

    cl::Buffer rangesBuf;
    cl::Buffer cloudBuf;
    cl::Buffer projectionBuf;
    cl::Buffer projectionInferenceBuf;
    cl::Buffer cloudInferenceBuf;

    float *rangesPtr;     //!< Holds all 2D lidar scans.
    int rangesSize = -1;  //!< Size of rangesPtr.

    uint8_t *cloudPtr;   //!< Holds point cloud generated by krnl_ranges_to_cloud.
    int cloudSize = -1;  //!< Size of cloudPtr.

    float *projectionPtr;     //!< Holds projection image generated by krnl_ranges_to_projection.
    int projectionSize = -1;  //!< Size of projectionPtr.

    float *projectionInferencePtr;
    int projectionInferenceSize = -1;

    uint8_t *cloudInferencePtr;
    int cloudInferenceSize = -1;

    /**
     * @brief Find Xilinx device.
     * @return True if found.
     */
    bool findDevice();

    /**
     * @brief Load binary from xclbin file.
     * @param xclbin Path to .xclbin.
     * @return True on success.
     */
    bool loadBinary(const std::string &xclbin);

   public:
    /**
     * @brief Construct a new Kernel Lidar Proc object but dont touch FPGA yet.
     */
    KernelLidarProc() = default;

    /**
     * @brief Construct a new Kernel Lidar Proc object and load it to FPGA.
     * @param xclbin Path to .xclbin file.
     */
    KernelLidarProc(const std::string &xclbin);

    /**
     * @brief Destroy the Kernel Lidar Proc object.
     *
     */
    ~KernelLidarProc();

    /**
     * @brief Load .xclbin to FPGA.
     * @param xclbin Path to .xclbin.
     * @return True on success.
     */
    bool init(const std::string &xclbin);

    /**
     * @brief Finish all the work with rangesToClouds.
     */
    void deinit();

    /**
     * @brief Allocate buffers required by rangesToClouds.
     * @param rangesSize Total number of samples from all 2D scans.
     * @param cloudSize Size of cloud point in bytes.
     * @return True on success.
     */
    bool allocateBuffers(int rangesSize, int cloudSize, int projectionSize);

    /**
     * @brief Set some arguments that are persistent for the lifetime of krnl_ranges_to_cloud.
     * @param num2DScans Number of 2D scans per full scan.
     * @param single2DScanSize  Size of single 2D scan in samples.
     * @param scan2DStartAngle Start angle of 2D scan in radians.
     * @param scan2DAngleInc  Angle increment of 2D scan in radians.
     * @param centerOffset Offset from center of the cradle (threaded rod) to 2D LIDAR.
     * @return True on success.
     */
    bool setArgsCloudGen(unsigned int single2DScanSize, unsigned int num2DScans, float scan2DStartAngle, float scan2DAngleInc, float centerOffset);

    bool setArgsProjectionGen(unsigned int single2DScanSize, unsigned int num2DScans, float scan2DStartAngle, float scan2DAngleInc, float scan2DMaxRange, float stepperEndstopAngle, unsigned int imgWidth, unsigned int imgHeight);

    bool setArgsInferenceCloudGen(unsigned int single2DScanSize, unsigned int num2DScans, float scan2DStartAngle, float scan2DAngleInc, float stepperEndstopAngle, float centerOffset, unsigned int imgWidth, unsigned int imgHeight);

    /**
     * @brief Insert one 2D scan into ranges buffer at given offset. The ranges must fit into the pre allocated buffer.
     * @param ranges Ranges to put into ranges buffer.
     * @param offset Offset from start of the buffer.
     */
    void setRangesChunk(const std::vector<float> &ranges, unsigned int offset);

    /**
     * @brief Run the rangesToCloud.
     * @param stepperStartAngle Start angle of the stepper for recent full scan (the one loaded via setRangesChunk).
     * @param stepperAngleInc Angle increment of the stepper motor for recent full scan.
     * @return True on success.
     */
    bool runCloudGen(float stepperStartAngle, float stepperAngleInc);

    /**
     * @brief Run the rangesToProjection.
     * @param stepperStartAngle Start angle of the stepper for recent full scan (the one loaded via setRangesChunk).
     * @param stepperAngleInc Angle increment of the stepper motor for recent full scan.
     * @return True on success.
     */
    bool runProjectionGen(float stepperStartAngle, float stepperAngleInc);

    bool runInferenceCloudGen(float stepperStartAngle, float stepperAngleInc, const std::vector<float> &projectionInferenceData);

    /**
     * @brief Copy runCloudGen's result from OpenCL's buffer into given vector.
     * @param buf Vector to copy result to.
     */
    void getCloudBuf(std::vector<uint8_t> &buf);

    /**
     * @brief Copy runProjectionGen's result from OpenCL's buffer into given vector.
     * @param buf Vector to copy result to.
     */
    void getProjectionBuff(std::vector<float> &buf);

    void getInferenceCloudBuf(std::vector<uint8_t> &buf);
};